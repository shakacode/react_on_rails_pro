# Server-side rendering with code-splitting using Loadable/Components
by ShakaCode

*Last updated Jan 27, 2020*

## Introduction
Previously, the code-splitting feature was implemented using `react-loadable`.
But it's status is not clear, since it doesn't receive any update from July, 2019.
After work on reducing the boilerplate, we found another library that well suited our needs.
It's also mentioned in the official reactjs documentation:
https://reactjs.org/docs/code-splitting.html#reactlazy

## Installation

```
yarn add  @loadable/babel-plugin @loadable/component @loadable/server @loadable/webpack-plugin
```

Short description:
`@loadable/babel-plugin` - The plugin transforms your code to be ready for Server Side Rendering. 
https://loadable-components.com/docs/babel-plugin/#transformation

`@loadable/component` - Main library for creating loadable components.
`@loadable/server` - Has functions for collecting chunks and provide style, script, link tags for the server.
`@loadable/webpack-plugin` - The plugin to create a stats file with all chunks, assets information.


## Configuration

The configuration is much less than for the previous way with `react-loadable`.
These instructions mainly repeat the steps from the official doc, but with some additions specifically to react_on_rails_pro.
https://loadable-components.com/docs/getting-started/

### Webpack

#### Server config

There are only two things that you need to add in the server config:
```
{
  target: 'node',
  plugins: [
    ...,
    new webpack.optimize.LimitChunkCountPlugin({ maxChunks: 1 })
  ]
}
```

Here is the explanation:

`target: 'node'` is required to be able to run the server bundle with the dynamic import logic on nodejs.
If that is not done, webpack will add browser-specific functions to fetch the chunks into the bundle, which throws an error on server-rendering.

`new webpack.optimize.LimitChunkCountPlugin({ maxChunks: 1 })`
The react_on_rails_pro vm-renderer expects only one single server-bundle. In other words, we can't and don't need to split the server bundle.

#### Client config

For the client config we only need to add the plugin:
```
{
  plugins: [
    ...,
     new LoadablePlugin({ filename: 'loadable-stats.json' })
  ]
}
```
This plugin collects all the information about entrypoints, chunks, and files, that have these chunks and creates a stats file during client bundle build. This stats file is used later to map rendered components to file assets.


### Babel

As from docs:
> The plugin transforms your code to be ready for Server Side Rendering

It also generates proper chunk name. So, no more need 
to add magic comment `webpackChunkName: '...'` into `import()` call to specify chunk name.

Add this to `babel.config.js`:
```
{
  "plugins": ["@loadable/babel-plugin"]
}
```
https://loadable-components.com/docs/babel-plugin/


### Convert components into loadable components

Instead of importing the component directly, use a dynamic import:

```
import load from '@loadable/component'
const MyComponent = load(() => import('./MyComponent'))
```

### Server and client entries

#### Client

In the client bundle, we need to wrap `hydrate` call into `loadableReady` function.
So, hydration will be fired only after all necessary chunks preloads.
Note, that there is `ClientApp` registering as `App`. 

```
import React from 'react';
import ReactOnRails from 'react-on-rails';
import { hydrate } from 'react-dom'
import { loadableReady } from '@loadable/component'
import App from './App';

const ClientApp = (props, railsContext, domId) => {
  loadableReady(() => {
    const root = document.getElementById(domId)
    hydrate(<App {...props} />, root)
  })
}

ReactOnRails.register({
  App: ClientApp,
});
```


#### Server

The purpose of the server function is to collect all rendered chunks and pass them as script, link, style tags to the rails view.

```
import React from 'react';
import ReactOnRails from 'react-on-rails';
import { ChunkExtractor } from '@loadable/server'
import App from './App'
import path from 'path'

const ServerApp = (props, railsContext) => {
  // This file was generated by `LoadablePlugin` in client webpack config.
  const statsFile = path.resolve('./path/to/loadable-stats.json')

  // This object is used to search filenames by corresponding chunk names.
  const extractor = new ChunkExtractor({ statsFile, entrypoints: ['client-bundle'] })

  // It creates the wrapper `ChunkExtractorManager` around `App` to collect chunk names of rendered components.
  const jsx = extractor.collectChunks(<App {...props} railsContext={railsContext} />)

  const componentHtml = renderToString(jsx);

  return {
    renderedHtml: {
      componentHtml,
      // Returns all the files with rendered chunks for furture insert into rails view.
      linkTags: extractor.getLinkTags(),
      styleTags: extractor.getStyleTags(),
      scriptTags: extractor.getScriptTags()
    }
  };
};


ReactOnRails.register({
  App: ServerApp,
});
```

## Rails view

On the rails side it can be used like this:

```
<% 
  res = react_component_hash("App", props: {}, prerender: true) 
  content_for :link_tags, res['linkTags'] 
  content_for :style_tags, res['styleTags'] 
  content_for :script_tags, res['scriptTags'] 
%>
<%= res['componentHtml'].html_safe %>
```
