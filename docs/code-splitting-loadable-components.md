# Server-side rendering with code-splitting using Loadable/Components
by ShakaCode

*Last updated Jan 27, 2020*

## Introduction
Previously, the code-splitting feature was implemented using `react-loadable`.
But it's status is not clear, since it doesn't receive any update from July, 2019.
After work on reducing the boilerplate, we found another library that well suited our needs.
It's also mentioned in the official reactjs documentation:
https://reactjs.org/docs/code-splitting.html#reactlazy

## Installation

```
yarn add  @loadable/babel-plugin @loadable/component @loadable/server @loadable/webpack-plugin
```

Short description:
`@loadable/babel-plugin` - The plugin transforms your code to be ready for Server Side Rendering. 
https://loadable-components.com/docs/babel-plugin/#transformation

`@loadable/component` - Main library for creating loadable components.
`@loadable/server` - Has functions for collecting chunks and provide style, script, link tags for the server.
`@loadable/webpack-plugin` - The plugin to create a stats file with all chunks, assets information.


## Configuration

The configuration is much less than for the previous way with `react-loadable`.
It mostly repeats the steps from the official doc, but with some additions specifically to react_on_rails_pro.
https://loadable-components.com/docs/getting-started/

### Webpack

#### Server config

There are only two things need to do add in the server config:
```
{
  target: 'node',
  plugins: [
    ...,
    new webpack.optimize.LimitChunkCountPlugin({ maxChunks: 1 })
  ]
}
```

Here is the explanation:

`target: 'node'` is required to be able to run server bundle that have dynamic import logic inside on the nodejs.
If not do that, webpack will add browser-specific functions to fetch chunk into the bundle, which throws the error on server-rendering.

`new webpack.optimize.LimitChunkCountPlugin({ maxChunks: 1 })`
react_on_rails_pro vm-renderer expecting one single server-bundle. Than it will be transferred to specific folder or to the separate web-server.

#### Client config

For the client config we only need to add the plugin:
```
{
  plugins: [
    ...,
     new LoadablePlugin({ filename: 'loadable-stats.json' })
  ]
}
```
This plugin collects all the information about entrypoints, chunks, and files, that have these chunks and creates a stats file during client bundle build. This stats file is used later to map rendered components to file assets.


### Babel

As from docs:
> The plugin transforms your code to be ready for Server Side Rendering, it turns a loadable call

It also generates proper chunk name. So, no more need 
to add magic comment `webpackChunkName: '...'` into `import()` call to specify chunk name.

Add this to `babel.config.js`:
```
{
  "plugins": ["@loadable/babel-plugin"]
}
```
https://loadable-components.com/docs/babel-plugin/


### Convert components into loadable components

It's simple. Instead of importing the component directly, use dynamic import:
```
import load from '@loadable/component'
const MyComponent = load(() => import('./MyComponent'))
```

### Server and client entries

#### Client

In the client bundle, we need to wrap `hydrate` call into `loadableReady` function.
So, hydration will be fired only after all necessary chunks preloads.
Note, that there is `ClientApp` registering as `App`. 

```
import React from 'react';
import ReactOnRails from 'react-on-rails';
import { hydrate } from 'react-dom'
import { loadableReady } from '@loadable/component'
import App from './App';

const ClientApp = (props, railsContext, domId) => {
  loadableReady(() => {
    const root = document.getElementById(domId)
    hydrate(<App {...props} />, root)
  })
}

ReactOnRails.register({
  App: ClientApp,
});
```


#### Server

The purpose of the server function is to collect all rendered chunks and pass them as a script, link, style tags to the rails view.

```
import React from 'react';
import ReactOnRails from 'react-on-rails';
import { ChunkExtractor } from '@loadable/server'
import App from './App'
import path from 'path'

const ServerApp = (props) => {
  const statsFile = path.resolve('./path/to/loadable-stats.json')
  const extractor = new ChunkExtractor({ statsFile, entrypoints: ['client-bundle'] })
  const jsx = extractor.collectChunks(<App {...props} />)

  const componentHtml = renderToString(jsx);

  return {
    renderedHtml: {
      componentHtml,
      linkTags: extractor.getLinkTags(),
      scriptTags: extractor.getScriptTags()
    }
  };
};


ReactOnRails.register({
  App: ServerApp,
});
```


```
const statsFile = path.resolve('./path/to/loadable-stats.json')
```
This file was generated by `LoadablePlugin` in client webpack config.

```
const extractor = new ChunkExtractor({ statsFile, entrypoints: ['client-bundle'] })
```
This object is used to search filenames by corresponding chunk names.

```
const jsx = extractor.collectChunks(<App {...props} />)
```
It creates the wrapper `ChunkExtractorManager` around `App` to collect chunk names of rendered components.

```
 linkTags: extractor.getLinkTags(),
 scriptTags: extractor.getScriptTags()
```
Returns all the files with rendered chunks for furture insert into rails view.


## Rails view

On the rails side it can be used like this:

```
<% 
  res = react_component_hash("App", props: {}, prerender: true) 
  content_for :link_tags, res['linkTags'] 
  content_for :style_tags, res['styleTags'] 
  content_for :script_tags, res['scriptTags'] 
%>
<%= res['componentHtml'].html_safe %>
```
